<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Low level C and C++</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
<div>
    <h1>Low level C and C++</h1>
    <p>Most introduction to programming class teach Java or Python, but the language they should teach is C.</p>
    <h2>1. Global, dynamic local, and static local variable.</h2>

<p>When I first learn C I only know that the location in which a C variable is defined change the scope of the variable, that global variable can be accessed anywhere in the file and final program, local var is only accessed within the function in which it's defined, and static local variable is the most confusing, there are also static global var and static function to add to the confusion. But when one look at the assembly things become clear, global var is accessible anywhere because they are defined with .word directive and a label. The .word directive give the var an effective address and a label to reference that address, hence the reason why global var can be accessed anywhere. Dynamic local var is created on the stack, by pushing the stack down by 1 word then store the value of the var in there, the var will be accessed using offset from the fp (frame pointer) register, offset of the first dynamic local is -1, then the one after that is -2, for argument/parameter the offset is +2 for the first parameter (the first from left to right), more about function calling later. Because local variable is on the stack, it does not have a label, its address will change after each f() call because the stack will get clear off when the function finish, again more on this later, that's why local variable only exist inside the function which created it. Static local var, is local var created with the keyword static. The definition is that static local var, is that it's like local var but it persists its value across function call, what is that mean? and how? Static local var, create using that .word directive with label, so yes it's like global var, and yes you can use static local var in an assembly file just like global var by using its label, but then it will defeat the purpose of using static local var in the first place which mean it's only access with the function it's declare. So how? the answer is using different label, Ex, let say we have a global var x, and a static local var in a function also name x. In assembly, the label for global x is just its name "x", but the static local var have the label in this way:

"@s" : indicate static var, "0,1,..." start from 0 and incremented by 1 for each successive static local var, thus each label is unique , "_" underscore, the name of static local var (x), so the label: "@s0_x".

This help differentiate between global and static local that have the same name. But what happen if I want to access the global x and static local x in the same function in C code? --> use address and pointer. </p>

<h2>2. Function calling and return. </h2>

<p>f() short for function, caller is f() that calling another f(), the f() that get called is called f(). To understand how f() calling work let examine simple case then complicate case later. The simple case is the called have no parameter, parameter and argument is basically the same thing, but we use two different name to indicate which context whether it's var that caller pass to called then it's argument, if it's inside the definition of called then it's parameter. What is a function? it's a block of instructions, that when we want to execute this block we jump to the first instruction in the function. How can we return? we save the return address, which is the instruction after the jump instruction to the f(), where? in a special register that use only to save return address. How can a f() return its computed value? in a register, usually the default register, but almost any register that are not special registers is fine, then in the caller, the return value can be accessed in the register that called save. Things get complicated when the called call another function, now we have a big problem, the return register of the first called will get overwrite, then we can not return to the original caller, so we need to save the return register value somewhere, which is on the stack, but only when the called call another called thus, in an optimized compiler, the compiler can look ahead to see if a f() will call another f() to decide if it should use the stack to save return address, in a non-optimized compiler, the compiler always save return address, it's simple, less efficient, less bug too. Ok so the first thing need to save is return address (1) on the stack, then there are 2 more values of the caller that need to be save on the stack of the called by the called which are fp and return address of caller, then before the called finish, it need to restore fp, then return address, then use this address to return. The last step is after return to caller, the caller will pop parameters off the stack, by increase it with the total amount of arguments, increase because the stack grow down. In the case of 0 parameter, then there is no need to pop stack.

For a function that have parameter, the caller is the one push these value on the stack, because the called can't pass these value to itself. Because we want to access parameter from left to right, we need to push the parameter right to left. The first parameter is offset +2, the next (second from left) is +3. Local var will be allocate on stack so the first local var has offset -1, second local var's offset is -2. At the start of any function including main() because main is a called function got called by startup code. At the start of every f(), lr and fp, need to be saved. then after save on stack, we need to make fp point to the same address of sp, then the fp can be use with offset. After all the logic, before return to caller there is a sequence of popping value in stack off into appropriate register, but it need to start first by making sp point to the same address of fp, then the first pop save fp, second pop save return address, finally use return address to return. </p>



<h2>3. Pointer.<h2>

<p>
    Pointer is address of variable. When a variable's value is the address of other variable, that variable is the pointer. There is no arrow inside computer. In assembly, there is this special instruction called "load register" ldr, that do the pointer magic, it take in an register which store the address, then get the value of the input address. If the pointer is local variable, which is almost always the case, then there need to be two ldr instruction, one to get the value (which is the address of wanted var) on the stack, then the second ldr to use that address to get the value. To dereference pointer use str (store register) which store value into given address.
</p>



<h2>4. Parameter passing. </h2>

<p>Parameter passing sounds simple, but not quite. You probably know that there are pass-by-value in which a function get copy of argument in its parameter and pass-by-reference/address in which a function get the actual value not copy, at least that's how I understand it the first time hearing these concept. Well, in truth, there is no pass-by-reference/address only pass-by-value. The reason why pass-by-reference/address can change the value of var outside its scope is because the pass in parameter is pointer, which then be used to dereference to change the value. Another confusing things is that when a function affect something outside it's scope, it's knows to have a "side effect", I think a better name for "side effect" is "non-local effect", I mean, where is this "side"? 

Variable length passing mean the argument number is vary. A popular example is the printf() which can take in many number of argument. So how can a function able to take in indeterminable argument? In C, there are this called macro which is basically text that will be replaced by C compiler, the code that will be put in will depend on the argument of the macro. For example, let say we have a sum() that take in unknown amount of int argument, let see how this function is created in C first then we will see the assembly which where all the logic happen. The parameter of sum function:

int sum(int argnum, ...) // the argnum is total additional argument , (...) indicate this function is variable f()

inside the f() we have a macro name va_list p; which will hold the address of second parameter, a macro va_start(p, argnum); this macro is code that will make p point to second parameter. Then because of the logic of f() into sum all variable argument, we have a while loop that increase a local sum var. 

sum = sum + va_arg(p, int);

You can probably guess that va_arg(p, int); return value that p point to, but it also increase p by 1 to point to next parameter, each time it's called. The int argnum is total arguments (not including the first, Ex sum(2, 5, 6) argnum is 2) can be use to know how many additional argument are there. 

*Note: This does not mean you can create a variable length f() then call it with at run time with variable input, the code for this f() is generate at compile time, not run time. For function with same name but different parameter, see overloading function (in C++, not in C).
</p>


<h2>5. Struct.</h2>

<p>A struct can save data with different type which different from array which can store only one type. At assembly level, a struct is simply .zero directive depend on its size, and a label if it's global var, if it's created inside a function, then there is no directive or label, the location of struct (address of it's first field) is on the function's stack. A struct can be passed by value or by reference (copy all value of struct or just copy 1 address of struct). When pass by value we need to copy all value of the struct field on stack. The field is push is opposite direction (the field at lower location is pushed first), therefore in the function, the first field (top location) is the first parameter, with offset of 2 from fp. </p>



<h2>6. Array.</h2>

<p>Array is quite complicated when it's created on stack (which is almost always the case). We will talk about this case unless indicate otherwise. In the case the array is not initialize, then it's simple, we simply decrease the stack depend on the length of the array, Ex for an integer array with 3 elements we decrease the stack by the amount of byte needed to store these array. In the case the array is initialized, we need to push each value onto the stack from right to left, Ex:

 int ar[3] = {10, 20, 30};

We will push 30, then 20, then 10. The reason for doing this is so that we can use index number to get the value at each index in array. The address of the array is the offset from the function's fp, so for the array of length 3, the address of the array on the stack relative to fp is fp - 3, this is the address that store value of a[0], then by using the index let say 2, we can add this to the address of array, fp - 3, so we have fp - 1 which is the address that store value 30, a[2]. If array is global, it have label to access address.

String is character array in C, so to have a string var in a function in C, we create a character array that have enough space for all character plus 1 null character. To have a string as local var, mean it's not create by .word, mean there is no label, mean we need to save each character on the stack, the way to have string in function is the same, we push each character from right to left, so the null character always push first, then to access the first character, which mean s[1] is fp -3 + 1 is fp -2 which is B, s[0] is fp, -3 which is A and s[2] is fp -3 + 2 = fp -1 = ' \0 '.</p>



<h2>7. Function name overloading C++.</h2>

<p>The basic idea of function overloading are functions with same name but different parameter in oder, type, amount, are legal, and that you can distinguish each function by their parameter. You can take a wild guess that at assembly, the label is different base on the argument its has, which is compiler dependence, is called parameter encoding. For example, the parameter encoding in LCC is this:

start with @, then function name, $ to separate f() name and parameter, the parameter is denoted as c for char, i for int, etc, the the parameter is an pointer it has p before, *int = pi. So a f(),  fun(*i, c) has the label:   @fun$pic. If the parameter is an object, Ex, fun(Point i) then the label is @fun$5Point, 5 is the amount of character in object, the number is needed to separate from let say an "struct i -> f(i obj)" and "f(int i)"

There is something called reference parameter in C++, and it's call pass-by-reference, so now we have pass-by value/address/reference, but they are all pass-by-value the only different is the value being copy is a pointer (address) that can the deference. 

Question: Why invent a new name for something that is not new just to hide detail? To make programming more confusing? </p>



<h2>8. Objects and inheritance. </h2>

<p>Object oriented programming is the topic that usually be taught first in CS major plan, and in my opinion, that is a bad choice, as least in my experience, I learn little and confuse more. Things like inheritance, encapsulation, polymorphism, abstraction, which beside the weird names that make the person talking about them sound smart, help nothing in describing what is it and why it has to do with programming. I hear something like "class is a blueprint" and "use blueprint to create object" and "object is something that has data and function inside it" they are all vague. The language of choice is Java, it's a high level language, but I would rather go with Python if I learn high level language.

In C, there is struct, a data structure that can have different data type which are accessed by using pointer. In C++ there are class and object, inside class are fields which can be data and function. So one natural question to ask is: if an object has function in it, are there separated functions generated for each object? The answer is no, it can not because that will be very inefficient. So all function in the same class will call one function in the class, the function will get access to the address of the object by the object's address, so there are actually 1 extra parameter that get hide away to make more magic and more confusion for function in class. So now we know that object is just struct, and function in object received address of object to access its data, that why for each object call, the function can access the data of object.     

Thing start to get complicated when get to inheritance and virtual function. in OOP a class can be derived from another class, the derived class inhered (has all the fields that its parent class has) from its parent class. What decided which f() to call? If the pointer of parent object change and point to child object, when invoke a f(), it's the pointer that decide which f() is called. But what if we want the child f() to be call? Then we need something called virtual f(), when a function has keyword virtual in parent class, all the child class f() will also be virtual. If a f() is virtual, it's the object that the pointer point to that decide the f() to be called not the pointer. For this to work, in the object the first field store the address to a table that will pointer to its virtual f(), that table is called virtual table, so if an object has 2 fields, it will have 3 empty word, 1 for pointer to virtual table, the assembly code instead of using label to the function, will dereference this address and use it to branch instead.

Finally, the idea of constructor, sound complicated when describe in OOP, but it simply just constructor f() of child call constructor of parent with the argument to initialize the field that define in parent class, then when its comeback to child constructor, the child constructor will initialize its extra field.
    </p>




    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
</div>
</body>
</html>
